# Pagination

## Pagination의 필요성
클라이언트가 요청하는 게시글이나 상품 등의 목록이 총 100만개인 경우, 매번 전체를 조회하게되면 매우 비 효율적이게 될 것이다.
하지만 데이터를 20개~100개로 나워서 가져온다면 더 효율적으로 데이터를 가져올 수 있고 클라이언트도 데이터를 다루기 좋을 것이다.

## Pagination구현 방법 두가지 
1. Offset 방식: Offset과 Limit 예약어를 사용하여 select 전체결과 중 일부만 가져오는 방법
    > `Offset`: 조회를 시작할 기준점
2. Cursor 방식: Cursor는 어떤 한 레코드를 가리키는 포인터이고 이 cursor가 가리키는 레코드부터 일정 개수를 가져오는 방법

## Offset 방식의 Pagination 처리
- 클라이언트: `페이지당 요청 자료의 갯수`와 `현재페이지 번호`를 파라메터로 요청
- 서버: 클라이언트의 요청 파라미터를 통해 `Offset 값을 구하고` 쿼리 구성하여 데이터를 가져온다.

- 예시
    > - `현재패이지`:1, `페이지당 요청 자료의 갯수`: 20 일때, `Offset`: (1-1)*20 = 0
    > - `현재패이지`:2, `페이지당 요청 자료의 갯수`: 20 일때, `Offset`: (2-1)*20 = 20 
    > - `현재패이지`:3, `페이지당 요청 자료의 갯수`: 20 일때, `Offset`: (2-1)*20 = 40
    > - ...

- 쿼리 예시
    > - SELECT * FROM table LIMIT `페이지당 자료의 개수` OFFSET `offset값`

## OffSet 방식의 단점
### 1. 뒷부분 쿼리 속도 저하
   - Offset의 값이 늘어날 수록 속도가 느려진다. 그 이유는 매번 데이터를 확인하여 해당 Offset 수 만큼 지나간 후에 데이터를 반환하기 떄문이다.
   - 속도 테스트 결과 [참고 블로그](https://betterdev.tistory.com/17#-----%--OFFSET%--%EA%B-%--%EC%--%--%--%EB%--%B-%EB%A-%B-%--%EC%BF%BC%EB%A-%AC%--%EC%--%-D%EB%-F%--%--%EC%B-%A-%EC%-D%B-%--%ED%--%-C%EC%-A%A-%ED%-A%B-)
   - 이러한 단점의 예시
     - 사용자가 구글 검색을 통해 1,000,000번쨰 자료에 접근했고 이 자료가 수많은 사람들에게 공유된다면 그 수많은 사용자들은 해당 자료에 접근하기 위해 오랜 시간이 걸릴 수 있다.
### 2. 데이터 **누락**과 **중복**
   - 잦은 추가와 삭제가 있을경우 데이터의 중복과 누락이 발생할 수 있다.
     - **누락 시나리오**
       - 사용자가 1페이지 리스트를 보는 중이다.
       - 운영자가 1페이지에서 자료 2개를 삭제한다.
       - 사용자가 2페이지로 넘어간다.
       - => 이떄, 삭제된 자료 2개만큼의 자료를 사용자는 못보게 될 수 있다. Offset방식은 매번 데이터의 갯수를 세어서 결과를 반환하기 떄문.
     - **중복 시나리오**
       - 사용자가 1페이지 리스트를 보는 중이다.
       - 운영자가 자료 2개를 등록한다.
       - 사용자가 2페이지로 넘어간다.
       - => 이떄, 사용자는 새로 등록된 자료로 인해 2페이지로 넘어간 자료 2개를 2페이지에서 또 보게된다.

## Cursor 방식의 Pagination 처리
- 클라이언트: 이전에 받은 데이터의 마지막 부분을 파라메터로 넘겨준다. 
- 서버: 클라이언트의 요청 파라미터로 받은 레코드 이후의 데이터를 조회하여 반환해준다.

- 쿼리 예시
  > SELECT * FROM table <br>
  > WHERE {기준필드} <(>) {클라이언트로 부터 받은 레코드의 기준필드값} <br> 
  > ORDER BY {기준필드} ASC(DESC) <br>
  > LIMIT 20;

> 주의: Cursor의 기준이 되는 필드는 고윳값을 가져야한다.
> - ex, PK로 사용 되는 값들은 보통 고윳값을 가지기떄문에 BoardNo같은건 기준이 될 수 있는데 
> - 상품의 가격 같은 것을 기준으로 하면 같은 가격인 것이 여러개라면 여러 상품을 뛰어넘고 다음 리스트들을 불러올 수도 있다.

## Cursor 방식의 단점
1. 구현이 복잡하다
    - 특히 정렬조건이 많을 수록 더 복잡해진다.
2. 여러 페이지를 건너 뛰어야 한다면 부적절한 방식이다.
    - 이전 데이터의 마지막 레코드를 기준으로 다음 데이터들을 불러오기 때문

# 요약

## Offset 방식
### 장점
1. 구현과 쿼리가 쉽다.
2. 여러 페이지를 한번에 넘어 갈 수 있다.
### 단점
1. 데이터의 중복, 누락이 발생할 수 있다.
2. 데이터가 많고 뒷 페이지로 갈 수록 성능이 떨어진다.

## Cursor 방식
### 장점
1. 필요한 데이터 부분만 효율적으로 불러올 수 있다. -> 일정한 성능을 보장한다.
### 단점
1. 정렬조건이 많아질 수록 구현이 어렵다(front, back 모두에게)
2. 한번에 여러페이지를 건너 뛰어야하는 경우 좋지 않다.

### reference
[Pagination이란 - Offset vs Cursor, Tstory](https://betterdev.tistory.com/17)
[페이지네이션 방법론 비교(Offset vs Cursor), Tstory](https://one-armed-boy.tistory.com/entry/%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-%EB%B0%A9%EB%B2%95%EB%A1%A0-%EB%B9%84%EA%B5%90Offset-vs-Cursor)